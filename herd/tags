!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACTIVE	one_sided_consol.cpp	/^    ACTIVE,$/;"	e	enum:CoreState	file:
APPS	Makefile	/^APPS    := main$/;"	m
CFLAGS	Makefile	/^CFLAGS  := -O3 -Wall -Werror -Wno-unused-result -I ..\/libhrd\/ -I ..\/mica\/$/;"	m
CONSOLIDATED	one_sided_consol.cpp	/^    CONSOLIDATED$/;"	e	enum:CoreState	file:
CONSOLIDATING	one_sided_consol.cpp	/^    CONSOLIDATING,$/;"	e	enum:CoreState	file:
CoreState	one_sided_consol.cpp	/^enum CoreState$/;"	g	file:
DGRAM_BUF_SIZE	client.c	5;"	d	file:
HERD_GET_REQ_SIZE	main.h	24;"	d
HERD_LOG_CAP	main.h	18;"	d
HERD_MICA_OFFSET	main.h	13;"	d
HERD_NUM_BKTS	main.h	17;"	d
HERD_NUM_KEYS	main.h	20;"	d
HERD_OP_GET	main.h	14;"	d
HERD_OP_PUT	main.h	15;"	d
HERD_PUT_REQ_SIZE	main.h	27;"	d
HERD_VALUE_SIZE	main.h	21;"	d
LAT_CAP	one_sided_consol.cpp	/^    static constexpr int LAT_CAP = 4096;$/;"	m	class:Scheduler	file:
LD	Makefile	/^LD      := gcc -O3$/;"	m
LDFLAGS	Makefile	/^LDFLAGS := ${LDFLAGS} -libverbs -lrt -lpthread -lmemcached -lnuma$/;"	m
LatSample	one_sided_consol.cpp	/^    struct LatSample$/;"	s	class:Scheduler	file:
MASTER_P0_ID	master.c	6;"	d	file:
MASTER_SHM_KEY	main.h	43;"	d
MAX_Q	one_sided_consol.cpp	/^constexpr int MAX_Q = 64;   \/\/ Max Queue length$/;"	v
MAX_SERVER_PORTS	main.h	30;"	d
MAX_THREADS	one_sided_consol.cpp	/^constexpr int MAX_THREADS = 4;$/;"	v
MPMCQueue	one_sided_consol.cpp	/^class MPMCQueue$/;"	c	file:
NUM_CLIENTS	main.h	32;"	d
NUM_UD_QPS	main.h	36;"	d
NUM_WORKERS	main.h	31;"	d
OFFSET	main.h	45;"	d
OP_DELETE	one_sided_consol.cpp	/^    OP_DELETE,$/;"	e	enum:RequestType	file:
OP_GET	one_sided_consol.cpp	/^    OP_GET,$/;"	e	enum:RequestType	file:
OP_PUT	one_sided_consol.cpp	/^    OP_PUT,$/;"	e	enum:RequestType	file:
OP_RANGE	one_sided_consol.cpp	/^    OP_RANGE,$/;"	e	enum:RequestType	file:
OP_UPDATE	one_sided_consol.cpp	/^    OP_UPDATE$/;"	e	enum:RequestType	file:
Q_A	one_sided_consol.cpp	/^constexpr double Q_A = 0.2; \/\/ Queue Down threshold-> Core consolidation$/;"	v
Q_B	one_sided_consol.cpp	/^constexpr double Q_B = 0.9; \/\/ Queue Up threshold -> Load Balancing$/;"	v
RR_SIZE	main.h	44;"	d
Request	one_sided_consol.cpp	/^struct Request$/;"	s	file:
RequestType	one_sided_consol.cpp	/^enum RequestType$/;"	g	file:
SCHEDULING_TICK	one_sided_consol.cpp	/^constexpr int SCHEDULING_TICK = 16;$/;"	v
SLEEPING	one_sided_consol.cpp	/^    SLEEPING,$/;"	e	enum:CoreState	file:
SLO_NS	one_sided_consol.cpp	/^    static constexpr uint64_t SLO_NS = (uint64_t)SLO_THRESHOLD_MS * 1'000'000ULL;$/;"	m	class:Scheduler	file:
SLO_THRESHOLD_MS	one_sided_consol.cpp	/^constexpr int SLO_THRESHOLD_MS = 5;$/;"	v
STARTED	one_sided_consol.cpp	/^    STARTED,$/;"	e	enum:CoreState	file:
Scheduler	one_sided_consol.cpp	/^    Scheduler(int tid) : thread_id(tid)$/;"	f	class:Scheduler
Scheduler	one_sided_consol.cpp	/^class Scheduler$/;"	c	file:
Task	one_sided_consol.cpp	/^    Task(CoroCall *src, int tid, int uid, int type = 0)$/;"	f	struct:Task
Task	one_sided_consol.cpp	/^struct Task$/;"	s	file:
UNSIG_BATCH	main.h	39;"	d
UNSIG_BATCH_	main.h	40;"	d
USE_POSTLIST	main.h	37;"	d
WINDOW_NS	one_sided_consol.cpp	/^    static constexpr uint64_t WINDOW_NS = 2ULL * 1000000ULL; \/\/ 2ms$/;"	m	class:Scheduler	file:
WINDOW_SIZE	main.h	35;"	d
base_port_index	main.h	/^  int base_port_index;$/;"	m	struct:thread_params
bind_cpu	one_sided_consol.cpp	/^void bind_cpu(int cpu_num)$/;"	f
block_self	one_sided_consol.cpp	/^    void block_self(int utask_id) { block_hint = utask_id; }$/;"	f	class:Scheduler
block_task	one_sided_consol.cpp	/^    void block_task(Task &&t)$/;"	f	class:Scheduler
blocked	one_sided_consol.cpp	/^    std::unordered_map<int, Task> blocked;$/;"	m	class:Scheduler	file:
blue	run-machine.sh	/^function blue() {$/;"	f
blue	run-servers.sh	/^function blue() {$/;"	f
core_consolidation	one_sided_consol.cpp	/^int core_consolidation(Scheduler &sched, int tid)$/;"	f
core_state	one_sided_consol.cpp	/^std::atomic<CoreState> core_state[MAX_THREADS];$/;"	v
cv_	one_sided_consol.cpp	/^    std::condition_variable cv_;$/;"	m	class:MPMCQueue	file:
cv_mutexes	one_sided_consol.cpp	/^std::mutex cv_mutexes[MAX_THREADS];$/;"	v
cvs	one_sided_consol.cpp	/^std::condition_variable cvs[MAX_THREADS];$/;"	v
detect_SLO_violation	one_sided_consol.cpp	/^    bool detect_SLO_violation()$/;"	f	class:Scheduler
detect_SLO_violation_slice	one_sided_consol.cpp	/^    bool detect_SLO_violation_slice()$/;"	f	class:Scheduler
emplace	one_sided_consol.cpp	/^    void emplace(Task &&task)$/;"	f	class:Scheduler
enqueue_to_wait_list	one_sided_consol.cpp	/^    void enqueue_to_wait_list(Task &&task)$/;"	f	class:Scheduler
g_rx	one_sided_consol.cpp	/^} g_rx;$/;"	v	typeref:class:MPMCQueue
get_random_permutation	client.c	/^int* get_random_permutation(int n, int clt_gid, uint64_t* seed) {$/;"	f
get_type	one_sided_consol.cpp	/^    int get_type() const { return task_type; }$/;"	f	struct:Task
gettid	one_sided_consol.cpp	/^pid_t gettid()$/;"	f
id	main.h	/^  int id;$/;"	m	struct:thread_params
is_done	one_sided_consol.cpp	/^    bool is_done() const$/;"	f	struct:Task
is_empty	one_sided_consol.cpp	/^    bool is_empty()$/;"	f	class:Scheduler
is_idle	one_sided_consol.cpp	/^    bool is_idle()$/;"	f	class:Scheduler
lat_cnt	one_sided_consol.cpp	/^    int lat_cnt = 0; \/\/ valid count (<= LAT_CAP)$/;"	m	class:Scheduler	file:
lat_idx	one_sided_consol.cpp	/^    int lat_idx = 0; \/\/ next write pos$/;"	m	class:Scheduler	file:
lat_ns	one_sided_consol.cpp	/^        uint32_t lat_ns;$/;"	m	struct:Scheduler::LatSample	file:
load_balancing	one_sided_consol.cpp	/^int load_balancing(int from_tid, int to_tid)$/;"	f
m_	one_sided_consol.cpp	/^    mutable std::mutex m_;$/;"	m	class:MPMCQueue	file:
main	main.c	/^int main(int argc, char* argv[]) {$/;"	f
main	one_sided_consol.cpp	/^int main()$/;"	f
master	one_sided_consol.cpp	/^void master(Scheduler &sched, int tid, int coro_count)$/;"	f
mutex	one_sided_consol.cpp	/^    std::mutex mutex;            \/\/ Mutex for Wait list$/;"	m	class:Scheduler	file:
noexcept	one_sided_consol.cpp	/^    Task(Task &&other) noexcept$/;"	m	struct:Task	file:
now_ns	one_sided_consol.cpp	/^static inline uint64_t now_ns()$/;"	f	file:
num_client_ports	main.h	/^  int num_client_ports;$/;"	m	struct:thread_params
num_server_ports	main.h	/^  int num_server_ports;$/;"	m	struct:thread_params
p99_in_recent_window	one_sided_consol.cpp	/^    uint64_t p99_in_recent_window() const$/;"	f	class:Scheduler
pick_active_random	one_sided_consol.cpp	/^int pick_active_random(int self, int also_exclude = -1)$/;"	f
pick_and_lock_target_pow2	one_sided_consol.cpp	/^int pick_and_lock_target_pow2(int self)$/;"	f
post_mycoroutines_to	one_sided_consol.cpp	/^int post_mycoroutines_to(int from_tid, int to_tid)$/;"	f
postlist	main.h	/^  int postlist;$/;"	m	struct:thread_params
power_of_two_choices	one_sided_consol.cpp	/^int power_of_two_choices(int self)$/;"	f
print_worker	one_sided_consol.cpp	/^void print_worker(Scheduler &sched, int tid, int coroid)$/;"	f
process_request_on_worker	one_sided_consol.cpp	/^static void process_request_on_worker(const Request &r, int tid, int coroid)$/;"	f	file:
pump_external_requests_into	one_sided_consol.cpp	/^static inline void pump_external_requests_into(Scheduler &sched, int burst = 32)$/;"	f	file:
push	one_sided_consol.cpp	/^    void push(Request &&r)$/;"	f	class:MPMCQueue
push_bulk	one_sided_consol.cpp	/^    void push_bulk(std::deque<Request> &in)$/;"	f	class:MPMCQueue
q_	one_sided_consol.cpp	/^    std::deque<Request> q_;$/;"	m	class:MPMCQueue	file:
record_latency	one_sided_consol.cpp	/^    inline void record_latency(uint64_t start_ns)$/;"	f	class:Scheduler
resume	one_sided_consol.cpp	/^    void resume(Scheduler *sched)$/;"	f	struct:Task
run_client	client.c	/^void* run_client(void* arg) {$/;"	f
run_master	master.c	/^void* run_master(void* arg) {$/;"	f
run_worker	worker.c	/^void* run_worker(void* arg) {$/;"	f
rx_queue	one_sided_consol.cpp	/^    MPMCQueue rx_queue;$/;"	m	class:Scheduler	file:
sched_load	one_sided_consol.cpp	/^int sched_load(int c)$/;"	f
schedule	one_sided_consol.cpp	/^    void schedule()$/;"	f	class:Scheduler
schedulers	one_sided_consol.cpp	/^Scheduler *schedulers[MAX_THREADS] = {nullptr};$/;"	v
set_type	one_sided_consol.cpp	/^    void set_type(int type) { task_type = type; }$/;"	f	struct:Task
size	one_sided_consol.cpp	/^    size_t size() const$/;"	f	class:MPMCQueue
sleep_thread	one_sided_consol.cpp	/^void sleep_thread(int tid)$/;"	f
sleeping_flags	one_sided_consol.cpp	/^std::atomic<bool> sleeping_flags[MAX_THREADS];$/;"	v
source	one_sided_consol.cpp	/^    CoroCall *source = nullptr;$/;"	m	struct:Task	file:
start_time	one_sided_consol.cpp	/^    uint64_t start_time;$/;"	m	struct:Request	file:
state_active_to_consol	one_sided_consol.cpp	/^bool state_active_to_consol(int tid)$/;"	f
state_sleep_to_consol	one_sided_consol.cpp	/^bool state_sleep_to_consol(int tid)$/;"	f
steal_all	one_sided_consol.cpp	/^    void steal_all(std::deque<Request> &out)$/;"	f	class:MPMCQueue
thread_func	one_sided_consol.cpp	/^void thread_func(int tid, int coro_count)$/;"	f
thread_id	one_sided_consol.cpp	/^    int thread_id;$/;"	m	class:Scheduler	file:
thread_params	main.h	/^struct thread_params {$/;"	s
timed_producer	one_sided_consol.cpp	/^void timed_producer(int num_thread, int qps, int durationSec)$/;"	f
try_pop	one_sided_consol.cpp	/^    bool try_pop(Request &out)$/;"	f	class:MPMCQueue
ts_ns	one_sided_consol.cpp	/^        uint64_t ts_ns;$/;"	m	struct:Scheduler::LatSample	file:
update_percentage	main.h	/^  int update_percentage;$/;"	m	struct:thread_params
value	one_sided_consol.cpp	/^          key(other.key), value(other.value)$/;"	f	struct:Task
wait_list	one_sided_consol.cpp	/^    std::queue<Task> wait_list;  \/\/ Wait list (코루틴 대기)$/;"	m	class:Scheduler	file:
wake_all_threads	one_sided_consol.cpp	/^void wake_all_threads(int num_thread)$/;"	f
wake_task	one_sided_consol.cpp	/^    bool wake_task(int uid)$/;"	f	class:Scheduler
wake_up_thread	one_sided_consol.cpp	/^void wake_up_thread(int tid)$/;"	f
work_queue	one_sided_consol.cpp	/^    std::queue<Task> work_queue; \/\/ Work Queue (코루틴 스케줄)$/;"	m	class:Scheduler	file:
~Task	one_sided_consol.cpp	/^    ~Task()$/;"	f	struct:Task
