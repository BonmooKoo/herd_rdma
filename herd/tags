!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACTIVE	scheduler.cpp	/^    ACTIVE,$/;"	e	enum:CoreState	file:
APPS	Makefile	/^APPS     := main$/;"	m
CFLAGS	Makefile	/^CFLAGS   := -g -O3 -Wall -Werror -Wno-unused-result $(CPPFLAGS)$/;"	m
CONSOLIDATED	scheduler.cpp	/^    CONSOLIDATED$/;"	e	enum:CoreState	file:
CONSOLIDATING	scheduler.cpp	/^    CONSOLIDATING,$/;"	e	enum:CoreState	file:
CPPFLAGS	Makefile	/^CPPFLAGS := -I ..\/libhrd\/ -I ..\/mica\/$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS := -g -O3 -Wall -Werror -Wno-unused-result $(CPPFLAGS)$/;"	m
CoreState	scheduler.cpp	/^enum CoreState$/;"	g	file:
DGRAM_BUF_SIZE	client.cpp	13;"	d	file:
HERD_GET_REQ_SIZE	main.h	26;"	d
HERD_LOG_CAP	main.h	20;"	d
HERD_MICA_OFFSET	main.h	15;"	d
HERD_NUM_BKTS	main.h	19;"	d
HERD_NUM_KEYS	main.h	22;"	d
HERD_OP_GET	main.h	16;"	d
HERD_OP_PUT	main.h	17;"	d
HERD_PUT_REQ_SIZE	main.h	29;"	d
HERD_VALUE_SIZE	main.h	23;"	d
LAT_CAP	scheduler.cpp	/^    static constexpr int LAT_CAP = 4096;$/;"	m	class:Scheduler	file:
LD	Makefile	/^LD       := g++$/;"	m
LDFLAGS	Makefile	/^LDFLAGS  := -libverbs -lrt -lpthread -lmemcached -lnuma -lboost_system -lboost_coroutine -lboost_context$/;"	m
LatSample	scheduler.cpp	/^    struct LatSample$/;"	s	class:Scheduler	file:
MAIN_H_	main.h	2;"	d
MASTER_P0_ID	master.cpp	11;"	d	file:
MASTER_SHM_KEY	main.h	46;"	d
MAX_CORES	main.h	33;"	d
MAX_Q	scheduler.cpp	/^constexpr int MAX_Q = 64;   \/\/ Max Queue length$/;"	v
MAX_SERVER_PORTS	main.h	32;"	d
MPMCQueue	scheduler.cpp	/^class MPMCQueue$/;"	c	file:
NUM_CLIENTS	main.h	34;"	d
NUM_CORO	main.h	35;"	d
NUM_SHARDS	scheduler.cpp	/^constexpr int NUM_SHARDS = MAX_CORES; \/\/ 최대 worker 갯수 = 전체 Shard 갯수$/;"	v
NUM_UD_QPS	main.h	39;"	d
OFFSET	main.h	48;"	d
OP_DELETE	scheduler.cpp	/^    OP_DELETE,$/;"	e	enum:RequestType	file:
OP_GET	scheduler.cpp	/^    OP_GET,$/;"	e	enum:RequestType	file:
OP_PUT	scheduler.cpp	/^    OP_PUT,$/;"	e	enum:RequestType	file:
OP_RANGE	scheduler.cpp	/^    OP_RANGE,$/;"	e	enum:RequestType	file:
OP_UPDATE	scheduler.cpp	/^    OP_UPDATE$/;"	e	enum:RequestType	file:
Q_A	scheduler.cpp	/^constexpr double Q_A = 0.2; \/\/ Queue Down threshold-> Core consolidation$/;"	v
Q_B	scheduler.cpp	/^constexpr double Q_B = 0.9; \/\/ Queue Up threshold -> Load Balancing$/;"	v
RR_SIZE	main.h	47;"	d
Request	scheduler_defs.h	/^struct Request {$/;"	s
RequestType	scheduler.cpp	/^enum RequestType$/;"	g	file:
Route	scheduler_defs.h	/^struct Route {$/;"	s
SCHEDULING_TICK	scheduler.cpp	/^constexpr int SCHEDULING_TICK = 16;$/;"	v
SLEEPING	scheduler.cpp	/^    SLEEPING,$/;"	e	enum:CoreState	file:
SLO_NS	scheduler.cpp	/^    static constexpr uint64_t SLO_NS = (uint64_t)SLO_THRESHOLD_MS * 1'000'000ULL;$/;"	m	class:Scheduler	file:
SLO_THRESHOLD_MS	scheduler.cpp	/^constexpr int SLO_THRESHOLD_MS = 5;$/;"	v
STARTED	scheduler.cpp	/^    STARTED,$/;"	e	enum:CoreState	file:
Scheduler	scheduler.cpp	/^    Scheduler(int tid) : thread_id(tid)$/;"	f	class:Scheduler
Scheduler	scheduler.cpp	/^class Scheduler$/;"	c	file:
Task	scheduler_defs.h	/^    Task(CoroCall *src, int tid, int uid, int type = 0)$/;"	f	struct:Task
Task	scheduler_defs.h	/^struct Task$/;"	s
UNSIG_BATCH	main.h	42;"	d
UNSIG_BATCH_	main.h	43;"	d
USE_POSTLIST	main.h	40;"	d
WINDOW_NS	scheduler.cpp	/^    static constexpr uint64_t WINDOW_NS = 2ULL * 1000000ULL; \/\/ 2ms$/;"	m	class:Scheduler	file:
WINDOW_SIZE	main.h	38;"	d
base_port_index	main.h	/^  int base_port_index;$/;"	m	struct:thread_params
bind_cpu	scheduler.cpp	/^void bind_cpu(int cpu_num)$/;"	f
blue	run-machine.sh	/^function blue() {$/;"	f
blue	run-servers.sh	/^function blue() {$/;"	f
core_consolidation	scheduler.cpp	/^int core_consolidation(Scheduler &sched, int tid)$/;"	f
core_state	scheduler.cpp	/^std::atomic<CoreState> core_state[MAX_CORES];$/;"	v
cv_	scheduler.cpp	/^    std::condition_variable cv_;$/;"	m	class:MPMCQueue	file:
cv_mutexes	scheduler.cpp	/^std::mutex cv_mutexes[MAX_CORES];$/;"	v
cvs	scheduler.cpp	/^std::condition_variable cvs[MAX_CORES];$/;"	v
detect_SLO_violation	scheduler.cpp	/^    bool detect_SLO_violation()$/;"	f	class:Scheduler
detect_SLO_violation_slice	scheduler.cpp	/^    bool detect_SLO_violation_slice()$/;"	f	class:Scheduler
emplace	scheduler.cpp	/^    void emplace(Task &&task)$/;"	f	class:Scheduler
enqueue_to_wait_list	scheduler.cpp	/^    void enqueue_to_wait_list(Task &&task)$/;"	f	class:Scheduler
get_random_permutation	client.cpp	/^int* get_random_permutation(int n, int clt_gid, uint64_t* seed) {$/;"	f
get_type	scheduler_defs.h	/^    int get_type() const { return task_type; }$/;"	f	struct:Task
gettid	scheduler.cpp	/^pid_t gettid()$/;"	f
herd_master_loop	scheduler.cpp	/^void herd_master_loop(Scheduler &sched, int tid, volatile struct mica_op* req_buf) {$/;"	f
herd_worker_coroutine	scheduler.cpp	/^void herd_worker_coroutine(Scheduler &sched, int lwid, int coroid,$/;"	f
id	main.h	/^  int id;$/;"	m	struct:thread_params
is_done	scheduler_defs.h	/^    bool is_done() const$/;"	f	struct:Task
is_empty	scheduler.cpp	/^    bool is_empty()$/;"	f	class:Scheduler
is_idle	scheduler.cpp	/^    bool is_idle()$/;"	f	class:Scheduler
kv_instances	main.cpp	/^struct mica_kv kv_instances[MAX_CORES]; \/\/ KV index to save actual KV$/;"	v	typeref:struct:mica_kv
lat_cnt	scheduler.cpp	/^    int lat_cnt = 0; \/\/ valid count (<= LAT_CAP)$/;"	m	class:Scheduler	file:
lat_idx	scheduler.cpp	/^    int lat_idx = 0; \/\/ next write pos$/;"	m	class:Scheduler	file:
lat_ns	scheduler.cpp	/^        uint32_t lat_ns;$/;"	m	struct:Scheduler::LatSample	file:
load_balancing	scheduler.cpp	/^int load_balancing(int from_tid, int to_tid)$/;"	f
m_	scheduler.cpp	/^    mutable std::mutex m_;$/;"	m	class:MPMCQueue	file:
main	main.cpp	/^int main(int argc, char* argv[]) {$/;"	f
mutex	scheduler.cpp	/^    std::mutex mutex;            \/\/ Mutex for Wait list$/;"	m	class:Scheduler	file:
noexcept	scheduler_defs.h	/^    Task(Task &&other) noexcept$/;"	m	struct:Task
now_ns	scheduler.cpp	/^static inline uint64_t now_ns()$/;"	f	file:
num_client_ports	main.h	/^  int num_client_ports;$/;"	m	struct:thread_params
num_server_ports	main.h	/^  int num_server_ports;$/;"	m	struct:thread_params
owner	scheduler_defs.h	/^    std::atomic<int> owner;$/;"	m	struct:Route
p99_in_recent_window	scheduler.cpp	/^    uint64_t p99_in_recent_window() const$/;"	f	class:Scheduler
pick_active_random	scheduler.cpp	/^int pick_active_random(int self, int also_exclude = -1)$/;"	f
pick_and_lock_target_pow2	scheduler.cpp	/^int pick_and_lock_target_pow2(int self)$/;"	f
poll_owned_shards	scheduler.cpp	/^static inline void poll_owned_shards(Scheduler &sched, int my_tid, volatile struct mica_op* req_buf) {$/;"	f	file:
post_mycoroutines_to	scheduler.cpp	/^int post_mycoroutines_to(int from_tid, int to_tid)$/;"	f
postlist	main.h	/^  int postlist;$/;"	m	struct:thread_params
power_of_two_choices	scheduler.cpp	/^int power_of_two_choices(int self)$/;"	f
push	scheduler.cpp	/^    void push(Request &&r)$/;"	f	class:MPMCQueue
push_bulk	scheduler.cpp	/^    void push_bulk(std::deque<Request> &in)$/;"	f	class:MPMCQueue
q_	scheduler.cpp	/^    std::deque<Request> q_;$/;"	m	class:MPMCQueue	file:
record_latency	scheduler.cpp	/^    inline void record_latency(uint64_t start_ns)$/;"	f	class:Scheduler
resume	scheduler_defs.h	/^    void resume(Scheduler *sched)$/;"	f	struct:Task
route_tbl	main.cpp	/^Route route_tbl[MAX_CORES];              \/\/ Shard where client write thier request by RDMA Write$/;"	v
run_client	client.cpp	/^void* run_client(void* arg) {$/;"	f
run_master	master.cpp	/^void* run_master(void* arg) {$/;"	f
run_worker	worker.cpp	/^void* run_worker(void* arg) {$/;"	f
rx_queue	scheduler.cpp	/^    MPMCQueue rx_queue;$/;"	m	class:Scheduler	file:
sched_load	scheduler.cpp	/^int sched_load(int c)$/;"	f
schedule	scheduler.cpp	/^    void schedule(){$/;"	f	class:Scheduler
schedulers	scheduler.cpp	/^Scheduler *schedulers[MAX_CORES] = {nullptr};$/;"	v
set_type	scheduler_defs.h	/^    void set_type(int type) { task_type = type; }$/;"	f	struct:Task
shard_count	scheduler.cpp	/^    int shard_count;$/;"	m	class:Scheduler	file:
size	scheduler.cpp	/^    size_t size() const$/;"	f	class:MPMCQueue
sleep_thread	scheduler.cpp	/^void sleep_thread(int tid)$/;"	f
sleeping_flags	scheduler.cpp	/^std::atomic<bool> sleeping_flags[MAX_CORES];$/;"	v
source	scheduler_defs.h	/^    CoroCall *source = nullptr;$/;"	m	struct:Task
state_active_to_consol	scheduler.cpp	/^bool state_active_to_consol(int tid)$/;"	f
state_sleep_to_consol	scheduler.cpp	/^bool state_sleep_to_consol(int tid)$/;"	f
steal_all	scheduler.cpp	/^    void steal_all(std::deque<Request> &out)$/;"	f	class:MPMCQueue
thread_id	scheduler.cpp	/^    int thread_id;$/;"	m	class:Scheduler	file:
thread_params	main.h	/^struct thread_params {$/;"	s
try_pop	scheduler.cpp	/^    bool try_pop(Request &out)$/;"	f	class:MPMCQueue
ts_ns	scheduler.cpp	/^        uint64_t ts_ns;$/;"	m	struct:Scheduler::LatSample	file:
update_percentage	main.h	/^  int update_percentage;$/;"	m	struct:thread_params
value	scheduler_defs.h	/^          key(other.key), value(other.value)$/;"	f	struct:Task
wait_list	scheduler.cpp	/^    std::queue<Task> wait_list;  \/\/ Wait list (코루틴 대기)$/;"	m	class:Scheduler	file:
wake_all_threads	scheduler.cpp	/^void wake_all_threads(int num_thread)$/;"	f
wake_up_thread	scheduler.cpp	/^void wake_up_thread(int tid)$/;"	f
work_queue	scheduler.cpp	/^    std::queue<Task> work_queue; \/\/ Work Queue (코루틴 스케줄)$/;"	m	class:Scheduler	file:
~Task	scheduler_defs.h	/^    ~Task()$/;"	f	struct:Task
